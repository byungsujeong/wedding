<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>정병수 & 김선아 결혼예배</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <style>
    * {
      box-sizing: border-box;
    }
    
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow-x: hidden;
      background-color: #f8f9fa;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    
    #pdf-container {
      width: 100vw;
      max-width: 100vw;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #f8f9fa;
      padding: 0;
    }
    
    .page-container {
      position: relative;
      margin: 0;
      padding: 0;
      width: 100vw;
      max-width: 100vw;
      background-color: #fff;
      overflow: hidden;
    }
    
    /* 페이지 간 여백 최소화 */
    .page-container + .page-container {
      margin-top: 1px;
      border-top: 1px solid #e9ecef;
    }
    
    canvas {
      display: block;
      width: 100vw !important;
      max-width: 100vw !important;
      height: auto !important;
      margin: 0;
      padding: 0;
      vertical-align: top;
    }
    
    /* 텍스트 레이어 - 복사 가능한 텍스트 */
    .textLayer {
      position: absolute;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      line-height: 1.0;
      pointer-events: auto;
      user-select: text !important;
      -webkit-user-select: text !important;
      -moz-user-select: text !important;
      -ms-user-select: text !important;
      z-index: 2;
    }
    
    .textLayer span,
    .textLayer div {
      color: transparent !important;
      position: absolute;
      white-space: pre;
      cursor: text;
      transform-origin: 0% 0%;
      user-select: text !important;
      -webkit-user-select: text !important;
      -moz-user-select: text !important;
      -ms-user-select: text !important;
      pointer-events: auto;
      font-family: sans-serif;
    }
    
    .textLayer ::selection {
      background: rgba(0, 123, 255, 0.3) !important;
      color: transparent !important;
    }
    
    .textLayer ::-moz-selection {
      background: rgba(0, 123, 255, 0.3) !important;
      color: transparent !important;
    }
    
    /* 링크 레이어 - 클릭 가능한 링크 */
    .linkLayer {
      position: absolute;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      pointer-events: none;
      z-index: 3;
    }
    
    .linkLayer a {
      position: absolute;
      color: transparent;
      text-decoration: none;
      display: block;
      cursor: pointer;
      pointer-events: auto;
      border: 2px solid transparent;
      transition: all 0.2s ease;
      z-index: 10;
    }
    
    .linkLayer a:hover {
      background: rgba(255, 193, 7, 0.3) !important;
      border-color: rgba(255, 193, 7, 0.6);
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .linkLayer a:active {
      background: rgba(255, 193, 7, 0.5) !important;
      transform: scale(0.98);
    }
    
    /* 모바일 터치 최적화 */
    @media (max-width: 768px) {
      .linkLayer a {
        min-height: 44px;
        min-width: 44px;
      }
      
      .textLayer {
        font-size: 14px;
      }
      
      .page-container + .page-container {
        margin-top: 0;
        border-top: none;
      }
    }
    
    /* 매우 작은 화면 */
    @media (max-width: 480px) {
      .textLayer {
        font-size: 12px;
      }
      
      .linkLayer a {
        min-height: 48px;
        min-width: 48px;
      }
      
      .page-container + .page-container {
        margin-top: 0;
        border-top: none;
      }
    }
    
    /* 로딩 인디케이터 */
    .loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 18px;
      color: #495057;
      z-index: 1000;
      text-align: center;
      background: rgba(255, 255, 255, 0.95);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    
    .loading::after {
      content: '';
      display: block;
      width: 24px;
      height: 24px;
      border: 3px solid #dee2e6;
      border-radius: 50%;
      border-top-color: #007bff;
      animation: spin 1s linear infinite;
      margin: 10px auto 0;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* 디버깅용 - 텍스트 레이어 확인 */
    .debug-mode .textLayer {
      background: rgba(255, 0, 0, 0.1);
    }
    
    .debug-mode .textLayer span,
    .debug-mode .textLayer div {
      color: red !important;
      background: rgba(255, 255, 0, 0.2);
    }
    
    .debug-mode .linkLayer a {
      background: rgba(0, 255, 0, 0.3) !important;
      border: 2px solid green !important;
    }
  </style>
</head>
<body>
  <div class="loading" id="loading">PDF 로딩 중...</div>
  <div id="pdf-container"></div>

  <!-- PDF.js 라이브러리 로드 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script>
    const url = "wedding.pdf";
    const container = document.getElementById('pdf-container');
    const loading = document.getElementById('loading');
    const pdfjsLib = window['pdfjs-dist/build/pdf'];
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    // 디버그 모드 (URL에 ?debug=1 추가하면 활성화)
    const isDebugMode = new URLSearchParams(window.location.search).get('debug') === '1';
    if (isDebugMode) {
      document.body.classList.add('debug-mode');
      console.log('Debug mode enabled');
    }

    // 화면 너비에 맞는 최적 스케일 계산
    function getOptimalScale() {
      const screenWidth = window.innerWidth;
      
      if (screenWidth <= 480) return 1.2;
      if (screenWidth <= 768) return 1.5;
      return 2.0;
    }

    // 뷰포트 크기에 맞춰 캔버스 크기 조정
    function adjustCanvasSize(canvas, viewport) {
      const screenWidth = window.innerWidth;
      const scale = screenWidth / viewport.width;
      
      canvas.style.width = screenWidth + 'px';
      canvas.style.height = (viewport.height * scale) + 'px';
      canvas.width = screenWidth * (window.devicePixelRatio || 1);
      canvas.height = viewport.height * scale * (window.devicePixelRatio || 1);
      
      return scale;
    }

    // URL 유효성 검사 및 정리
    function sanitizeUrl(url) {
      if (!url) return null;
      
      // 기본적인 URL 패턴 검사
      const urlPattern = /^(https?:\/\/|mailto:|tel:)/i;
      if (urlPattern.test(url)) {
        return url;
      }
      
      // HTTP가 없는 경우 추가
      if (url.includes('.') && !url.startsWith('javascript:')) {
        return 'https://' + url;
      }
      
      return null;
    }

    pdfjsLib.getDocument(url).promise.then(pdf => {
      loading.style.display = 'none';
      console.log('PDF loaded successfully, pages:', pdf.numPages);
      
      const renderPage = num => {
        pdf.getPage(num).then(page => {
          console.log(`Rendering page ${num}`);
          const scale = getOptimalScale();
          const viewport = page.getViewport({ scale: scale });
          
          // 페이지 컨테이너 생성
          const pageContainer = document.createElement("div");
          pageContainer.className = "page-container";
          pageContainer.setAttribute('data-page-number', num);
          pageContainer.id = 'page-' + num;
          container.appendChild(pageContainer);

          // 캔버스 생성
          const canvas = document.createElement("canvas");
          const context = canvas.getContext("2d");
          pageContainer.appendChild(canvas);
          
          // 캔버스 크기를 화면에 맞게 조정
          const displayScale = adjustCanvasSize(canvas, viewport);
          
          // 페이지 컨테이너 높이 설정
          pageContainer.style.height = canvas.style.height;

          // 텍스트 레이어 생성
          const textLayerDiv = document.createElement("div");
          textLayerDiv.className = "textLayer";
          textLayerDiv.style.width = canvas.style.width;
          textLayerDiv.style.height = canvas.style.height;
          pageContainer.appendChild(textLayerDiv);

          // 링크 레이어 생성
          const linkLayerDiv = document.createElement("div");
          linkLayerDiv.className = "linkLayer";
          linkLayerDiv.style.width = canvas.style.width;
          linkLayerDiv.style.height = canvas.style.height;
          pageContainer.appendChild(linkLayerDiv);

          // 고해상도 렌더링을 위한 컨텍스트 스케일링
          const outputScale = window.devicePixelRatio || 1;
          context.scale(outputScale, outputScale);

          const renderContext = {
            canvasContext: context,
            viewport: page.getViewport({ scale: scale * displayScale })
          };

          // 페이지 렌더링
          const renderTask = page.render(renderContext);
          
          // 텍스트 콘텐츠와 링크 가져오기
          const textContent = page.getTextContent();
          const annotations = page.getAnnotations();

          Promise.all([renderTask.promise, textContent, annotations]).then(([_, textContent, annotations]) => {
            console.log(`Page ${num} rendered, processing text and links`);
            
            // 텍스트 레이어 렌더링
            const textViewport = page.getViewport({ scale: scale * displayScale });
            
            try {
              // PDF.js 최신 버전 방식
              if (pdfjsLib.TextLayer) {
                const textLayer = new pdfjsLib.TextLayer({
                  textContentSource: textContent,
                  container: textLayerDiv,
                  viewport: textViewport
                });
                textLayer.render();
                console.log(`Text layer rendered for page ${num} using new API`);
              } else {
                throw new Error('TextLayer not available');
              }
            } catch (error) {
              console.warn(`New TextLayer API failed for page ${num}:`, error);
              // 레거시 방식으로 폴백
              try {
                pdfjsLib.renderTextLayer({
                  textContentSource: textContent,
                  container: textLayerDiv,
                  viewport: textViewport,
                  textDivs: []
                });
                console.log(`Text layer rendered for page ${num} using legacy API`);
              } catch (legacyError) {
                console.error(`Both TextLayer methods failed for page ${num}:`, legacyError);
                // 수동으로 텍스트 레이어 생성
                createManualTextLayer(textContent, textLayerDiv, textViewport, num);
              }
            }

            // 링크 레이어 생성
            console.log(`Processing ${annotations.length} annotations for page ${num}`);
            annotations.forEach((annotation, index) => {
              if (annotation.subtype === 'Link') {
                console.log(`Creating link ${index} for page ${num}:`, annotation);
                const link = document.createElement('a');
                
                // URL 처리
                let linkUrl = null;
                if (annotation.url) {
                  linkUrl = sanitizeUrl(annotation.url);
                } else if (annotation.action && annotation.action.url) {
                  linkUrl = sanitizeUrl(annotation.action.url);
                }
                
                if (linkUrl) {
                  link.href = linkUrl;
                  link.target = '_blank';
                  link.rel = 'noopener noreferrer';
                  
                  // 링크 클릭 이벤트
                  link.addEventListener('click', function(e) {
                    console.log('Link clicked:', linkUrl);
                    // 모바일에서는 touchend 이벤트로 처리
                    if ('ontouchstart' in window) {
                      e.preventDefault();
                      window.open(linkUrl, '_blank', 'noopener,noreferrer');
                    }
                  });
                  
                  link.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Link touched:', linkUrl);
                    window.open(linkUrl, '_blank', 'noopener,noreferrer');
                  });
                } else if (annotation.dest) {
                  // 내부 링크 처리
                  link.href = '#page-' + annotation.dest;
                  link.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const targetPage = document.getElementById('page-' + annotation.dest);
                    if (targetPage) {
                      targetPage.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                  });
                } else {
                  console.log(`Skipping annotation ${index} - no valid URL or destination`);
                  return;
                }
                
                // 링크 위치 및 크기 계산
                const rect = annotation.rect;
                const pageHeight = textViewport.height;
                const scaleX = displayScale;
                const scaleY = displayScale;
                
                // PDF 좌표계를 HTML 좌표계로 변환
                const left = rect[0] * scaleX;
                const bottom = rect[1] * scaleY;
                const right = rect[2] * scaleX;
                const top = rect[3] * scaleY;
                
                // HTML에서는 top이 위에서부터의 거리
                const htmlTop = pageHeight - top;
                const width = right - left;
                const height = top - bottom;
                
                link.style.position = 'absolute';
                link.style.left = left + 'px';
                link.style.top = htmlTop + 'px';
                link.style.width = width + 'px';
                link.style.height = height + 'px';
                link.style.display = 'block';
                link.style.color = 'transparent';
                link.style.textDecoration = 'none';
                link.style.cursor = 'pointer';
                
                // 접근성을 위한 속성
                link.setAttribute('aria-label', '링크: ' + (linkUrl || '내부 링크'));
                link.setAttribute('data-link-index', index);
                link.setAttribute('data-page', num);
                
                // 터치 디바이스를 위한 최소 크기 보장
                if ('ontouchstart' in window) {
                  const minSize = 44;
                  if (width < minSize) {
                    link.style.width = minSize + 'px';
                    link.style.left = (left - (minSize - width) / 2) + 'px';
                  }
                  if (height < minSize) {
                    link.style.height = minSize + 'px';
                    link.style.top = (htmlTop - (minSize - height) / 2) + 'px';
                  }
                }
                
                linkLayerDiv.appendChild(link);
                console.log(`Link ${index} created for page ${num} at (${left}, ${htmlTop}) size (${width}, ${height})`);
              }
            });
            
            // 다음 페이지 렌더링
            if (num < pdf.numPages) {
              renderPage(num + 1);
            } else {
              console.log('All pages rendered successfully');
            }
          }).catch(error => {
            console.error(`Error rendering page ${num} content:`, error);
            if (num < pdf.numPages) {
              renderPage(num + 1);
            }
          });
        }).catch(error => {
          console.error(`Error loading page ${num}:`, error);
          if (num < pdf.numPages) {
            renderPage(num + 1);
          }
        });
      };
      
      renderPage(1);
    }).catch(error => {
      console.error('Error loading PDF:', error);
      loading.innerHTML = 'PDF 로딩 실패<br><small>파일을 확인해주세요.</small>';
      loading.style.color = '#dc3545';
    });

    // 수동 텍스트 레이어 생성 (폴백 함수)
    function createManualTextLayer(textContent, container, viewport, pageNum) {
      console.log(`Creating manual text layer for page ${pageNum}`);
      textContent.items.forEach(function(textItem, index) {
        const textDiv = document.createElement('span');
        textDiv.textContent = textItem.str;
        textDiv.style.position = 'absolute';
        textDiv.style.left = textItem.transform[4] + 'px';
        textDiv.style.top = (viewport.height - textItem.transform[5]) + 'px';
        textDiv.style.fontSize = Math.abs(textItem.transform[0]) + 'px';
        textDiv.style.fontFamily = textItem.fontName || 'sans-serif';
        textDiv.style.color = 'transparent';
        textDiv.style.cursor = 'text';
        textDiv.style.userSelect = 'text';
        textDiv.style.webkitUserSelect = 'text';
        textDiv.style.mozUserSelect = 'text';
        textDiv.style.msUserSelect = 'text';
        textDiv.setAttribute('data-text-index', index);
        container.appendChild(textDiv);
      });
      console.log(`Manual text layer created for page ${pageNum} with ${textContent.items.length} items`);
    }

    // 화면 크기 변경 시 재렌더링
    let resizeTimeout;
    window.addEventListener('resize', function() {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(function() {
        const currentWidth = window.innerWidth;
        if (Math.abs(currentWidth - (window.lastWidth || currentWidth)) > 50) {
          console.log('Screen size changed significantly, reloading...');
          window.lastWidth = currentWidth;
          location.reload();
        }
      }, 500);
    });

    window.lastWidth = window.innerWidth;

    // 텍스트 선택 테스트 함수
    window.testTextSelection = function() {
      const textLayers = document.querySelectorAll('.textLayer');
      console.log('Testing text selection on', textLayers.length, 'text layers');
      
      textLayers.forEach((layer, index) => {
        const spans = layer.querySelectorAll('span, div');
        console.log(`Text layer ${index} has ${spans.length} text elements`);
        
        spans.forEach((span, spanIndex) => {
          if (spanIndex < 3) { // 처음 3개만 로그
            console.log(`  Element ${spanIndex}:`, span.textContent, span.style.cssText);
          }
        });
      });
    };

    // 링크 테스트 함수
    window.testLinks = function() {
      const linkLayers = document.querySelectorAll('.linkLayer');
      console.log('Testing links on', linkLayers.length, 'link layers');
      
      linkLayers.forEach((layer, index) => {
        const links = layer.querySelectorAll('a');
        console.log(`Link layer ${index} has ${links.length} links`);
        
        links.forEach((link, linkIndex) => {
          console.log(`  Link ${linkIndex}:`, link.href, link.getBoundingClientRect());
        });
      });
    };

    // 페이지 로드 완료 후 테스트 함수 실행
    setTimeout(() => {
      if (isDebugMode) {
        console.log('Running debug tests...');
        window.testTextSelection();
        window.testLinks();
      }
    }, 3000);

    console.log('PDF viewer initialized');
  </script>
</body>
</html>

